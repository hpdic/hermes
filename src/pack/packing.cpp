/*
 * File: src/pack/packing.cpp
 * ------------------------------------------------------------
 * HERMES Packed Encryption/Decryption UDFs for MySQL
 *
 * This file defines two MySQL User-Defined Functions (UDFs) to
 * support group-wise homomorphic encryption and decryption of
 * integer vectors using the OpenFHE BFV scheme.
 *
 * FUNCTIONALITY:
 * ------------------------------------------------------------
 * 1. HERMES_PACK_CONVERT (Aggregate UDF)
 *    - Aggregates multiple INT values from a SQL GROUP BY.
 *    - Prepends the vector length as the first slot of the
 *      plaintext to ensure truncation correctness.
 *    - Constructs a packed BFV plaintext:
 *          P = {n, v₁, v₂, ..., vₙ}
 *    - Encrypts P, serializes ciphertext, and returns a base64
 *      string suitable for storage or transmission.
 *
 * 2. HERMES_DEC_VECTOR_BFV (Scalar UDF)
 *    - Accepts a base64 ciphertext string (from above).
 *    - Decrypts the packed BFV ciphertext.
 *    - Parses the first slot as `n`, and returns the next `n`
 *      slots (v₁ to vₙ) as a comma-separated string.
 *
 * MOTIVATION:
 * ------------------------------------------------------------
 * OpenFHE’s packed plaintexts are padded to batch size, and
 * do not persist slot count metadata across processes.
 *
 * To address this, we explicitly encode the slot count in
 * the first slot during encryption, allowing UDFs to recover
 * the intended vector length during decryption without relying
 * on OpenFHE internal APIs such as `SetLength()` or external
 * metadata side channels.
 *
 * USAGE EXAMPLES:
 *   INSERT INTO packed_cipher
 *   SELECT dept, HERMES_PACK_CONVERT(salary)
 *   FROM salaries
 *   GROUP BY dept;
 *
 *   SELECT dept, HERMES_DEC_VECTOR_BFV(packed_val)
 *   FROM packed_cipher;
 *
 * DEPENDENCIES:
 *   - OpenFHE v1.2.4
 *   - MySQL UDF API
 *   - Hermes internal crypto modules:
 *       + context.hpp
 *       + encrypt.hpp
 *       + keygen.hpp
 *       + serialize.hpp
 *       + base64.hpp
 *
 * AUTHOR:
 *   Dongfang Zhao (dzhao@cs.washington.edu)
 *   University of Washington
 *
 * LAST UPDATED:
 *   May 30, 2025
 */

#include <cstring>
#include <mysql/mysql.h>
#include <mysql/udf_registration_types.h>
#include <string>
#include <vector>

#include "context.hpp"
#include "encrypt.hpp"
#include "keygen.hpp"
#include "serialize.hpp"
#include "base64.hpp"

using hermes::crypto::decodeBase64;
using hermes::crypto::encodeBase64;

using namespace hermes::crypto;
using namespace lbcrypto;

struct PackState {
  std::vector<int64_t> values;
};

extern "C" bool HERMES_DEC_VECTOR_BFV_init(UDF_INIT *initid, UDF_ARGS *args, char *msg) {
  if (args->arg_count != 1 || args->arg_type[0] != STRING_RESULT) {
    std::strcpy(msg, "HERMES_DEC_VECTOR_BFV expects one base64 string.");
    return 1;
  }
  initid->maybe_null = 1;
  initid->max_length = 65535;
  initid->ptr = nullptr; // for output buffer

  return 0;
}

/*
 * HERMES_DEC_VECTOR_BFV
 * ------------------------------------------------------------
 * Scalar UDF: Decrypts a packed ciphertext and returns a
 * comma-separated string of integers.
 *
 * INPUT:
 *   - A Base64-encoded string representing a BFV ciphertext
 *     generated by HERMES_PACK_CONVERT.
 *
 * DECRYPTION PROTOCOL:
 * ------------------------------------------------------------
 * This function assumes that the input ciphertext was produced
 * by `HERMES_PACK_CONVERT`, which prepends the original vector
 * length (denoted as n) as the first slot of the BFV plaintext
 * before encryption.
 *
 * That is, the packed plaintext has the form:
 *   P = {n, v₁, v₂, ..., vₙ}
 *
 * On decryption, we:
 *   - Extract the full packed vector V = {n, v₁, ..., vₙ}
 *   - Interpret `n = V[0]` as the true payload length
 *   - Emit the values {v₁, ..., vₙ} as a comma-separated string
 *
 * This design avoids reliance on OpenFHE’s internal padding
 * behavior and ensures accurate truncation without invoking
 * SetLength() or storing side metadata.
 *
 * RETURN:
 *   - A string of the form "v₁,v₂,...,vₙ" corresponding to the
 *     decrypted contents of the packed plaintext, excluding the
 *     first metadata slot.
 *
 * EXAMPLE:
 *   SELECT HERMES_DEC_VECTOR_BFV(base64_ciphertext);
 *   → "1000,2000,1500"
 *
 * AUTHOR:
 *   Dongfang Zhao (dzhao@cs.washington.edu)
 *   University of Washington
 *   Last Updated: May 29, 2025
 */
extern "C" char *HERMES_DEC_VECTOR_BFV(UDF_INIT *initid, UDF_ARGS *args,
                                       char *result, unsigned long *length,
                                       char *is_null, char *error) {
  if (args->arg_count != 1 || args->arg_type[0] != STRING_RESULT) {
    *is_null = 1;
    *error = 1;
    return nullptr;
  }

  try {
    std::string encoded(args->args[0], args->lengths[0]);
    std::cerr << "[UDF] Input length: " << encoded.size() << std::endl;

    std::string decoded = decodeBase64(encoded);
    if (decoded.empty()) {
      std::cerr << "[UDF] Decoded base64 string is empty.\n";
      *is_null = 1;
      *error = 1;
      return nullptr;
    }    
    
    auto ctx = hermes::crypto::makeBfvContext();
    auto sk = loadSecretKey();
    auto ct = hermes::crypto::deserializeCiphertext(decoded);
    Plaintext pt;
    ctx->Decrypt(sk, ct, &pt);
    auto values = pt->GetPackedValue();
    if (values.empty()) {
      std::cerr << "[UDF] Empty plaintext!" << std::endl;
      *is_null = 1;
      *error = 1;
      return nullptr;
    }
    size_t real_len = static_cast<size_t>(values[0]);

    std::ostringstream oss;
    for (size_t i = 1; i <= real_len; ++i) {
      if (i > 1)
        oss << ",";
      oss << values[i];
    }
    std::string resultStr = oss.str();

    char *out = static_cast<char *>(malloc(resultStr.size() + 1));
    if (!out) {
      std::cerr << "[UDF] malloc failed" << std::endl;
      *is_null = 1;
      *error = 1;
      return nullptr;
    }
    std::memcpy(out, resultStr.data(), resultStr.size());
    out[resultStr.size()] = '\0';
    *length = resultStr.size();
    initid->ptr = out; // Let MySQL manage this buffer

    std::cerr << "[UDF] Returning string: " << out << std::endl;
    std::cerr << "[UDF] Output length: " << *length << std::endl;

    return out;

  } catch (const std::exception &e) {
    std::cerr << "[UDF] Exception: " << e.what() << std::endl;
    *is_null = 1;
    *error = 1;
    return nullptr;
  } catch (...) {
    std::cerr << "[UDF] Unknown error occurred." << std::endl;
    *is_null = 1;
    *error = 1;
    return nullptr;
  }
}

extern "C" void HERMES_DEC_VECTOR_BFV_deinit(UDF_INIT *initid) {
  if (initid->ptr) {
    free(initid->ptr);
    initid->ptr = nullptr;
  }
}

// UDF initialization
extern "C" bool HERMES_PACK_CONVERT_init(UDF_INIT *initid, UDF_ARGS *args,
                                         char *message) {
  if (args->arg_count != 1 || args->arg_type[0] != INT_RESULT) {
    strcpy(message, "HERMES_PACK_CONVERT() expects a single INT argument.");
    return true;
  }

  initid->maybe_null = 0;
  initid->max_length = 1024 * 1024; // up to 1MB
  initid->ptr = reinterpret_cast<char*>(new PackState());    // custom aggregation buffer
  return false;
}

// Reset buffer for each GROUP
extern "C" void HERMES_PACK_CONVERT_clear(UDF_INIT *initid, char *is_null,
                                          char *error) {
  auto *state = reinterpret_cast<PackState *>(initid->ptr);
  state->values.clear();
}

// Add each value in the GROUP
extern "C" void HERMES_PACK_CONVERT_add(UDF_INIT *initid, UDF_ARGS *args,
                                        char *is_null, char *error) {
  auto *state = reinterpret_cast<PackState *>(initid->ptr);
  if (!args->args[0])
    return; // skip NULL
  int64_t val = *reinterpret_cast<long long *>(args->args[0]);
  state->values.push_back(val);
}

/*
 * HERMES_PACK_CONVERT
 * ------------------------------------------------------------
 * Aggregate UDF: Encrypts and returns packed ciphertext.
 *
 * This function aggregates a group of integer values, encodes
 * them using OpenFHE’s BFV scheme into a packed plaintext, then
 * encrypts the plaintext and serializes the ciphertext.
 *
 * DESIGN NOTE:
 * ------------------------------------------------------------
 * To ensure correct recovery of the original slot length across
 * process boundaries (e.g., in MySQL UDF execution), the first
 * slot of the packed plaintext is explicitly reserved to store
 * the original vector length.
 *
 * Specifically:
 *   - Let V = {v₁, v₂, ..., vₙ} be the original integer values.
 *   - We prepend the slot count n as the first slot:
 *       P = {n, v₁, v₂, ..., vₙ}
 *   - The full plaintext becomes P, of length (n + 1).
 *   - This slot count is used at decryption time to correctly
 *     truncate trailing garbage values introduced by OpenFHE’s
 *     default batch size padding.
 *
 * RETURN:
 *   A Base64-encoded ciphertext string containing the encrypted
 *   packed plaintext, with the first slot reserved for metadata.
 *
 * AUTHOR:
 *   Dongfang Zhao (dzhao@cs.washington.edu)
 *   University of Washington
 *   Last Updated: May 29, 2025
 */
extern "C" char *HERMES_PACK_CONVERT(UDF_INIT *initid, UDF_ARGS *args,
                                     char *result, unsigned long *length,
                                     char *is_null, char *error) {
  auto *state = reinterpret_cast<PackState *>(initid->ptr);
  if (state->values.empty()) {
    *is_null = 1;
    return nullptr;
  }

  static std::string buffer; // shared buffer
  buffer.clear();

  // Encrypt
  auto ctx = makeBfvContext();
  auto pk = loadPublicKey();
  auto sk = loadSecretKey();

  std::vector<int64_t> packed_values;
  packed_values.push_back(
      static_cast<int64_t>(state->values.size())); // slot count as first value
  packed_values.insert(packed_values.end(), state->values.begin(),
                       state->values.end());
  
  auto pt = ctx->MakePackedPlaintext(packed_values);
  pt->SetLength(state->values.size());
  auto ct = encrypt(ctx, pk, pt);
  // Serialize keys to disk (for debug/demo only)
  std::ofstream pubout(kPubKeyPath, std::ios::binary);
  if (!pubout.is_open()) {
    std::cerr << "[ERROR] Failed to open public key file for writing.\n";
  } else {
    pubout << hermes::crypto::serializePublicKey(pk);
    pubout.close();
    std::cerr << "[INFO] Public key written successfully.\n";
  }
  std::ofstream secout(kSecKeyPath, std::ios::binary);
  if (!secout.is_open()) {
    std::cerr << "[ERROR] Failed to open secret key file for writing.\n";
  } else {
    secout << hermes::crypto::serializeSecretKey(sk);
    secout.close();
    std::cerr << "[INFO] Secret key written successfully.\n";
  }

  // Serialize
  buffer = encodeBase64(serializeCiphertext(ct));
  *length = buffer.size();
  return const_cast<char *>(buffer.c_str());
}

// Free memory
extern "C" void HERMES_PACK_CONVERT_deinit(UDF_INIT *initid) {
  delete reinterpret_cast<PackState *>(initid->ptr);
}